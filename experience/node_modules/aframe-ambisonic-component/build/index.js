module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("omnitone/build/omnitone.esm");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* global AFRAME */
if (typeof AFRAME === 'undefined') {
  throw new Error('Component attempted to register before AFRAME was available. Did you include A-Frame?');
}

if (false) {}

__webpack_require__(2);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "omnitone/build/omnitone.esm"
var omnitone_esm_ = __webpack_require__(0);
var omnitone_esm_default = /*#__PURE__*/__webpack_require__.n(omnitone_esm_);

// CONCATENATED MODULE: ./src/log.js
/* global DEBUG */
var log;
var warn;
var AFRAME = window.AFRAME;

if (false) {} else {
  log = warn = function warn() {};
}


// CONCATENATED MODULE: ./src/ambisonic-audio.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

 // import * as AFRAME from 'aframe';
// import * as THREE from 'three';

var ambisonic_audio_AFRAME = window.AFRAME;
var THREE = window.THREE; // imported by aframe



function setBooleanAttribute(element, attr, value) {
  if (element) {
    if (value) {
      element.setAttribute(attr, true);
    } else {
      element.removeAttribute(attr);
    }
  }
}

var MIN_ORDER = 1;
var MAX_ORDER = 3;
var isSafari = false; // /safari/i.test(Omnitone.browserInfo.name);

var isIOS = false; // /iP(ad|od|hone)/.test(Omnitone.browserInfo.platform);

var safariChannelMap = function safariChannelMap(_ref) {
  var _ref2 = _slicedToArray(_ref, 4),
      w = _ref2[0],
      x = _ref2[1],
      y = _ref2[2],
      z = _ref2[3];

  return [y, w, x, z];
};

function setRotationMatrixFromCamera(renderer, camera) {
  renderer.setRotationMatrix4(camera.matrixWorldInverse.elements);
}

function channelCount(order) {
  var orderPlus1 = order + 1;
  return orderPlus1 * orderPlus1;
}

var boundMethods = ['setCamera', 'onEntityChange', 'onLoadSound', 'onPlaySound', 'onPauseSound', 'onEndSound'];
var channelMapSchemes = {
  // acn: n => n,
  sid: [0, 3, 1, 2, 8, 4, 7, 5, 6, 15, 9, 14, 10, 13, 11, 12],
  fuma: [0, 3, 1, 2, 6, 7, 5, 8, 4, 12, 13, 11, 14, 10, 15, 9]
};
var intArrayRegex = /^([0-9]+)(\s*,\s*([0-9]+))*$/;
ambisonic_audio_AFRAME.registerComponent('ambisonic', {
  schema: {
    src: {
      type: 'audio'
    },
    sources: {
      type: 'array',
      default: []
    },
    loop: {
      type: 'boolean',
      default: true
    },
    autoplay: {
      type: 'boolean',
      default: false
    },
    useMediaElement: {
      type: 'boolean',
      default: true
    },
    order: {
      type: 'number',
      default: 1
    },
    channelMap: {
      parse: function parse(str) {
        if (typeof str === 'string') {
          str = str.trim().toLowerCase();
        }

        if (channelMapSchemes[str]) {
          return channelMapSchemes[str];
        }

        if (intArrayRegex.test(str)) {
          return str.split(',').map(parseFloat);
        }

        return [];
      },
      stringify: function stringify(value) {
        if (Array.isArray(value)) {
          return value.join(', ');
        }

        return value;
      },
      default: 'ACN'
    },
    mode: {
      default: 'ambisonic',
      oneOf: ['bypass', 'ambisonic', 'off']
    }
  },
  init: function init() {
    var _this = this;

    this.context = null;
    this.renderer = null;
    this.audio = null;
    this.mediaElement = null;
    this.audioSources = [];
    this.loading = false;
    this.ownMediaElement = false;
    this.playing = false; // bind any event handling methods

    boundMethods.forEach(function (name) {
      _this[name] = _this[name].bind(_this);
    }); // Update on entity change.

    this.el.addEventListener('componentchanged', this.onEntityChange);
  },
  update: function update(oldData) {
    var _this2 = this;

    var el = this.el;
    var sceneEl = el.sceneEl; // todo: handle changed scene element
    // try to get context from scene audio listener. otherwise, make our own

    var listener = sceneEl.audioListener;
    var context = listener && listener.context || this.context || THREE.AudioContext.getContext(); // Wait for camera if necessary.

    this.camera = sceneEl.camera || null;
    sceneEl.addEventListener('camera-set-active', this.setCamera); // if context changed, then need to rebuild omnitone instance
    // todo: rebuild if type of Omnitone renderer (order) changed

    var _this$data = this.data,
        order = _this$data.order,
        src = _this$data.src,
        sources = _this$data.sources;
    var channels = channelCount(order);
    var useMediaElement = this.data.useMediaElement && (!sources || !(sources.length >= 2));
    var rebuildOmnitone = context !== this.context || !this.renderer || this.renderer.input.channelCount > 4 !== channels >= 4;

    if (rebuildOmnitone) {
      this.context = context;
      this.resumeAudioContext();

      if (this.renderer) {
        // clean up old renderer
        this.renderer.output.disconnect();
        this.renderer = null;
      }

      var createRenderer = channels === 4 ? omnitone_esm_default.a.createFOARenderer : omnitone_esm_default.a.createHOARenderer;
      var renderer = this.renderer = createRenderer(this.context, {
        ambisonicOrder: order
      });
      renderer.initialize().then(function () {
        if (renderer !== _this2.renderer || context !== _this2.context) {
          // things changed while we were initializing so abort
          return;
        }

        _this2.audio.gain.connect(_this2.renderer.input);

        renderer.output.connect(context.destination);

        _this2.updateAmbisonicSettings();
      });
      this.audio = new THREE.Audio(listener || {
        context: context,
        getInput: function getInput() {
          return context.destination;
        }
      });
      this.audio.gain.disconnect();
    }

    var rebuildSound = rebuildOmnitone || !!oldData.useMediaElement !== !!useMediaElement || oldData.src !== src || JSON.stringify(oldData.sources) !== JSON.stringify(sources);

    if (rebuildSound) {
      if (useMediaElement) {
        var newMediaElement = null;

        if (src instanceof window.HTMLMediaElement) {
          newMediaElement = src;
          this.ownMediaElement = false;
        } else if (src) {
          newMediaElement = document.createElement('audio');
          newMediaElement.src = src; // this.mediaElement.load();

          this.ownMediaElement = true;
        }

        if (this.mediaElement !== newMediaElement) {
          this.cleanMediaAssets();
        }

        if (newMediaElement) {
          newMediaElement.addEventListener('play', this.onPlaySound);
          newMediaElement.addEventListener('pause', this.onPauseSound);
          newMediaElement.addEventListener('load', this.onLoadSound);
          newMediaElement.addEventListener('canplay', this.onLoadSound);
          newMediaElement.addEventListener('ended', this.onEndSound);
        }

        if (!this.mediaElement && newMediaElement && this.ownMediaElement) {
          newMediaElement.onerror = function (evt) {
            warn('Error loading audio', src, evt);
          };

          newMediaElement.onloadedmetadata = function () {
            log('Audio metadata loaded', src, _this2.mediaElement);
          };
        }

        this.mediaElement = newMediaElement;
        this.audioSources = [];

        if (this.mediaElement) {
          this.audio.setMediaElementSource(this.mediaElement);
        } else if (this.audio.source) {
          this.audio.disconnect();
        }
      } else {
        // load audio buffer
        var url = src;

        if (src && typeof src !== 'string' && src instanceof window.HTMLMediaElement) {
          if (src.tagName.toLowerCase() === 'video') {
            throw new Error('Unable to load video as audio buffer');
          }

          url = src.src || src.srcObject || src.currentSrc;
        }

        if (sources && sources.length) {
          this.audioSources = sources;
        } else {
          this.audioSources = [url];
        }

        this.cleanMediaAssets();

        if (this.data.autoplay) {
          this.loadBuffer();
        }
      }
    }

    this.updatePlaybackSettings();
    this.updateAmbisonicSettings();
  },
  tick: function tick() {
    if (this.renderer && this.camera) {
      setRotationMatrixFromCamera(this.renderer, this.camera);
    }
  },
  play: function play() {
    if (this.data.autoplay) {
      this.playSound();
    }
  },
  pause: function pause() {
    this.pauseSound();
  },
  cleanMediaAssets: function cleanMediaAssets() {
    // clean up all sound assets
    if (this.mediaElement) {
      this.mediaElement.removeEventListener('play', this.playSound);
      this.mediaElement.removeEventListener('pause', this.onPauseSound);
      this.mediaElement.removeEventListener('load', this.onLoadSound);
      this.mediaElement.removeEventListener('canplay', this.onLoadSound);
      this.mediaElement.removeEventListener('ended', this.onEndSound);

      if (this.ownMediaElement) {
        this.mediaElement.pause();
        this.mediaElement.src = '';
        this.mediaElement.load();
      }

      this.mediaElement = null;
    }

    if (this.audio) {
      if (this.audio.isPlaying) {
        this.audio.stop();
      }

      if (this.audio.source) {
        this.audio.source.removeEventListener('ended', this.onEndSound);
      }

      this.audio.source = null;
      this.audio.buffer = null;
      this.audio.sourceType = 'empty';
    }

    if (this.loading) {
      // todo: find a way to abort loader
      this.loading = false;
    }
  },
  remove: function remove() {
    var el = this.el;
    var sceneEl = el && el.sceneEl;

    if (sceneEl) {
      sceneEl.removeEventListener('camera-set-active', this.setCamera);
    }

    this.el.removeEventListener('componentchanged', this.onEntityChange);
    this.disconnect();
    this.cleanMediaAssets();
  },
  setCamera: function setCamera(evt) {
    this.camera = evt.detail.cameraEl.getObject3D('camera');
  },
  // resume audio context
  resumeAudioContext: function resumeAudioContext() {
    if (this.context && this.context.resume && this.context.state === 'suspended') {
      return this.context.resume().catch(function () {});
    }

    return Promise.resolve();
  },
  loadBuffer: function loadBuffer() {
    var _this3 = this;

    this.resumeAudioContext().then(function () {
      if (_this3.loading || !_this3.audioSources.length) {
        return;
      }

      _this3.loading = true;
      var sources = JSON.stringify(_this3.audioSources);
      omnitone_esm_default.a.createBufferList(_this3.context, _this3.audioSources).then(function (results) {
        var audioBuffer = omnitone_esm_default.a.mergeBufferListByChannel(_this3.context, results);
        var useMediaElement = _this3.data.useMediaElement && (!sources || !(sources.length >= 2));

        if (!useMediaElement && sources === JSON.stringify(_this3.audioSources)) {
          _this3.audio.setBuffer(audioBuffer);

          _this3.onLoadSound();

          _this3.updatePlaybackSettings();

          if (_this3.playing) {
            _this3.playSound();
          }
        }
      }).catch(function (error) {
        warn('Unable to decode audio source', _this3.audioSources, error);
      });
    });
  },
  // set play state to start when loaded
  playSound: function playSound() {
    this.playing = true;
    this.resumeAudioContext();

    if (this.mediaElement) {
      var playPromise = this.mediaElement.play();

      if (playPromise) {
        playPromise.catch(function (e) {
          warn('Unable to play media', e.message);
        });
      }
    } else if (this.audio && !this.audio.isPlaying) {
      this.loadBuffer();

      if (this.audio.buffer) {
        this.audio.play();
        this.audio.source.addEventListener('ended', this.onEndSound);
        this.onPlaySound();
      }
    }
  },
  pauseSound: function pauseSound() {
    this.playing = false;

    if (this.mediaElement) {
      this.mediaElement.pause();
    } else if (this.audio && this.audio.isPlaying) {
      this.audio.pause();
      this.onPauseSound();
    }
  },
  stopSound: function stopSound() {
    if (this.mediaElement) {
      this.mediaElement.pause();
    } else if (this.audio) {
      this.audio.stop();
      this.onPauseSound();
    }
  },
  onPlaySound: function onPlaySound() {
    this.resumeAudioContext();
    this.el.emit('sound-play');
  },
  onPauseSound: function onPauseSound() {
    this.el.emit('sound-pause');
  },
  onLoadSound: function onLoadSound() {
    this.el.emit('sound-loaded');
  },
  onEndSound: function onEndSound() {
    if (this.audio && this.audio.source) {
      this.onPauseSound();
      this.audio.source.removeEventListener('ended', this.onEndSound);
    }

    this.el.emit('sound-ended');
  },

  /**
  * Update the Omnitone sound settings.
  */
  updateAmbisonicSettings: function updateAmbisonicSettings() {
    if (this.renderer) {
      if (this.renderer.setChannelMap) {
        var channelMap = this.data.channelMap.slice(0); // fill in any missing channel map values in case they're left out

        var channels = channelCount(this.data.order);

        for (var i = channelMap.length; i < channels; i++) {
          channelMap[i] = i;
        }

        channelMap.length = channels;
        /*
        Per various documents on the internet, Safari messes up the
        order of the channels, but that does not seem to be the case.
        Maybe it's been fixed in a recent version, so this is disabled
        for now.
        */

        this.renderer.setChannelMap(channelMap.length === 4 && isSafari ? safariChannelMap(channelMap) : channelMap);
      } // Mobile Safari cannot decode all the audio channels from a media element


      var _this$data2 = this.data,
          order = _this$data2.order,
          mode = _this$data2.mode;
      var validOrder = order >= MIN_ORDER && order <= MAX_ORDER;
      var renderingMode = (isIOS || !validOrder) && mode === 'ambisonic' ? 'bypass' : this.data.mode;
      this.renderer.setRenderingMode(renderingMode);
    }
  },

  /**
  * Update the playback settings.
  */
  updatePlaybackSettings: function updatePlaybackSettings() {
    if (this.mediaElement) {
      // only if we created this element
      if (this.ownMediaElement) {
        setBooleanAttribute(this.mediaElement, 'loop', this.data.loop);
        setBooleanAttribute(this.mediaElement, 'autoplay', this.data.autoplay);
      }
    } else if (this.audio) {
      this.audio.setLoop(this.data.loop);
      this.audio.autoplay = this.data.autoplay;
    } // todo: other props like playbackRate, detune, etc.

  },

  /**
  * When the entity's rotation is changed, update the Omnitone rotation accordingly.
  * @param {Event} evt
  */
  onEntityChange: function onEntityChange(evt) {
    if (evt.detail.name !== 'rotation') {
      return;
    }

    this.el.sceneEl.object3D.updateMatrixWorld(true); // todo: support rotating entity
  },
  disconnect: function disconnect() {
    if (this.audio) {
      this.audio.disconnect();
      this.audio.gain.disconnect();
    }

    if (this.renderer) {
      this.renderer.input.disconnect();
      this.renderer.output.disconnect();
    }
  }
});
ambisonic_audio_AFRAME.registerPrimitive('a-ambisonic', {
  defaultComponents: {
    'ambisonic': {}
  },
  mappings: {
    src: 'ambisonic.src',
    sources: 'ambisonic.sources',
    loop: 'ambisonic.loop',
    autoplay: 'ambisonic.autoplay',
    order: 'ambisonic.order',
    'use-media-element': 'ambisonic.useMediaElement',
    'channel-map': 'ambisonic.channelMap',
    mode: 'ambisonic.mode'
  }
});

/***/ })
/******/ ]);
//# sourceMappingURL=index.js.map